<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Editor - Comprehensive Auto-Expanded Suggestions</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #002ae2 0%, #78050f 100%);
            min-height: 100vh;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #container {
            width: 100%;
            height: 600px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        /* Dynamic styles will be injected here */
    </style>
</head>

<body>
    <div class="header">
        <h1>üéØ Monaco Comprehensive Auto-Expanded</h1>
        <p>Full-featured auto-expanding suggestions with hover, lens, and decorations</p>
    </div>

    <div id="container"></div>

    <script src="https://unpkg.com/monaco-editor@0.44.0/min/vs/loader.js"></script>
    <script>
        // Dataset configuration
        const dataset = {
            "content": `# Comprehensive Pattern Editor Demo

I always recieve emails, but teh system is slow.
Great work by @johndoe on the project!
Check out: https://api.openai.com/v1/chat/completions
We use **javascript** for development.

Try typing after these triggers:
@j (for @johndoe)
h (for hello)
w (for world)
j (for javascript)

WARNING: This is a warning message
SUCCESS: Operation completed successfully  
TODO: Add more examples with auto-expanded details

Position cursor after any letter and see auto-expanded suggestions!`,
            "styles": {
                "spelling-error": {
                    "css": "text-decoration: underline wavy red !important;",
                },
                "user-mention": {
                    "css": "color: #1da1f2 !important; background: rgba(29,161,242,0.1) !important; padding: 1px 2px !important; border-radius: 3px !important;",
                },
                "api-endpoint": {
                    "css": "color: #ff6b35 !important; text-decoration: underline !important;",
                },
                "token-count": {
                    "css": "color: #ffa500 !important;",
                },
                "keyword-highlight": {
                    "css": "color: #00ff88 !important; background: rgba(0,255,136,0.1) !important; padding: 1px 2px !important; border-radius: 3px !important;",
                },
                "greeting": {
                    "css": "color: #ff69b4 !important; background: rgba(255,105,180,0.1) !important; padding: 1px 2px !important; border-radius: 3px !important;",
                },
                "world": {
                    "css": "color: #32cd32 !important; background: rgba(50,205,50,0.1) !important; padding: 1px 2px !important; border-radius: 3px !important;",
                },
                "warning": {
                    "css": "background: rgba(255,193,7,0.2) !important; border-left: 3px solid #ffc107 !important; padding: 1px 4px !important;",
                },
                "success": {
                    "css": "background: rgba(40,167,69,0.2) !important; border-left: 3px solid #28a745 !important; padding: 1px 4px !important;",
                },
                "info": {
                    "css": "background: rgba(23,162,184,0.2) !important; border-left: 3px solid #17a2b8 !important; padding: 1px 4px !important;",
                }
            },
            "patterns": [
                {
                    "word": "hello",
                    "style": "greeting",
                    "info": `<strong>üéâ Hello</strong> - A friendly greeting<br/><br/>
                    <strong>Usage Examples:</strong><br/>
                    ‚Ä¢ "Hello, world!" - The classic programming greeting<br/>
                    ‚Ä¢ "Hello there!" - A casual greeting<br/>
                    ‚Ä¢ "Hello everyone" - Group greeting<br/><br/>
                    <strong>Etymology:</strong> From Old English "h«£l" meaning "whole" or "healthy"<br/><br/>
                    <strong>Related Phrases:</strong><br/>
                    ‚Ä¢ Hello darkness, my old friend<br/>
                    ‚Ä¢ Hello from the other side<br/>
                    ‚Ä¢ Say hello to my little friend<br/><br/>
                    <strong>Programming Context:</strong><br/>
                    The "Hello, World!" program is traditionally the first program written by students learning a new programming language.<br/><br/>
                    <strong>Cultural Impact:</strong><br/>
                    Used in over 200 programming languages as the introductory example.`,
                    "actions": [
                        {
                            "url": "https://en.wikipedia.org/wiki/%22Hello,_World!%22_program",
                            "label": "üìñ Wikipedia: Hello World",
                            "hover": true
                        }
                    ]
                },
                {
                    "word": "world",
                    "style": "world",
                    "info": `<strong>üåç World</strong> - The Earth and all its inhabitants<br/><br/>
                    <strong>Common Phrases:</strong><br/>
                    ‚Ä¢ "Hello, world!" - Programming tradition<br/>
                    ‚Ä¢ "World peace" - Global harmony<br/>
                    ‚Ä¢ "Around the world" - Global journey<br/>
                    ‚Ä¢ "World wide web" - The internet<br/><br/>
                    <strong>Related Terms:</strong> planet, earth, globe, universe, cosmos<br/><br/>
                    <strong>Fun Facts:</strong><br/>
                    ‚Ä¢ The "Hello, World!" program tradition started in 1972<br/>
                    ‚Ä¢ World population is over 8 billion people<br/>
                    ‚Ä¢ There are 195 countries in the world<br/>
                    ‚Ä¢ Earth is 4.54 billion years old<br/><br/>
                    <strong>In Different Languages:</strong><br/>
                    ‚Ä¢ Spanish: mundo<br/>
                    ‚Ä¢ French: monde<br/>
                    ‚Ä¢ German: Welt<br/>
                    ‚Ä¢ Japanese: ‰∏ñÁïå (sekai)<br/><br/>
                    <strong>Geography:</strong><br/>
                    Surface area: 510.1 million km¬≤<br/>
                    Oceans cover 71% of the surface`,
                    "actions": [
                        {
                            "url": "https://en.wikipedia.org/wiki/World",
                            "label": "üåê Wikipedia: World",
                            "hover": true
                        }
                    ]
                },
                {
                    "word": "recieve",
                    "style": "spelling-error",
                    "errorLabel": "Fix to 'receive'",
                    "errorReplace": "receive",
                    "errorSeverity": "error",
                    "info": `<strong>‚ùå Spelling Error</strong><br/><br/>
                    <strong>Correct spelling:</strong> receive<br/>
                    <strong>Common mistake:</strong> "i before e" rule confusion<br/><br/>
                    <strong>Memory tip:</strong> "I before E, except after C, or when sounded like A as in neighbor and weigh"<br/><br/>
                    <strong>Other examples:</strong><br/>
                    ‚Ä¢ achieve, believe, field, piece<br/>
                    ‚Ä¢ deceive, perceive, ceiling, receipt`
                },
                {
                    "word": "teh",
                    "style": "spelling-error",
                    "errorLabel": "Fix to 'the'",
                    "errorReplace": "the",
                    "errorSeverity": "error",
                    "info": `<strong>‚ùå Typo</strong><br/><br/>
                    <strong>Correct spelling:</strong> the<br/>
                    <strong>Common typing error:</strong> Transposed letters<br/><br/>
                    <strong>Prevention tips:</strong><br/>
                    ‚Ä¢ Slow down when typing common words<br/>
                    ‚Ä¢ Use spell check tools<br/>
                    ‚Ä¢ Practice typing accuracy`
                },
                {
                    "word": "johndoe",
                    "triggerCharacter": "@",
                    "triggerComplete": "johndoe",
                    "style": "user-mention",
                    "info": `<strong>üë§ John Doe</strong><br/>Software Developer<br/>üìä 2.3K followers<br/><br/>
                    <strong>Expertise:</strong><br/>
                    ‚Ä¢ Full-stack development<br/>
                    ‚Ä¢ React & Node.js<br/>
                    ‚Ä¢ Cloud architecture<br/><br/>
                    <strong>Recent Activity:</strong><br/>
                    ‚Ä¢ Contributed to 15 repositories this month<br/>
                    ‚Ä¢ Published 3 articles on Medium<br/>
                    ‚Ä¢ Spoke at TechConf 2024`,
                    "actions": [
                        {
                            "url": "https://twitter.com/johndoe",
                            "label": "üê¶ Twitter Profile",
                            "hover": true
                        },
                        {
                            "url": "https://linkedin.com/in/johndoe",
                            "label": "üíº LinkedIn Profile",
                            "hover": true
                        },
                        {
                            "url": "https://github.com/johndoe",
                            "label": "üêô GitHub Profile",
                            "hover": false,
                            "tooltip": true
                        }
                    ]
                },
                {
                    "word": "https://api.openai.com/v1/chat/completions",
                    "style": "api-endpoint",
                    "info": `<strong>üåê OpenAI Chat Completions API</strong><br/><br/>
                    <strong>Endpoint Details:</strong><br/>
                    ‚Ä¢ Method: POST<br/>
                    ‚Ä¢ Authentication: Bearer token required<br/>
                    ‚Ä¢ Rate limits apply<br/><br/>
                    <strong>Common Parameters:</strong><br/>
                    ‚Ä¢ model: gpt-3.5-turbo, gpt-4<br/>
                    ‚Ä¢ messages: Array of conversation messages<br/>
                    ‚Ä¢ temperature: 0.0-2.0 (creativity level)<br/>
                    ‚Ä¢ max_tokens: Response length limit<br/><br/>
                    <strong>Pricing:</strong><br/>
                    ‚Ä¢ GPT-3.5-turbo: $0.002/1K tokens<br/>
                    ‚Ä¢ GPT-4: $0.03/1K tokens (input)<br/><br/>
                    <strong>Response Format:</strong><br/>
                    Returns JSON with choices array containing generated text`,
                    "actions": [
                        {
                            "url": "https://platform.openai.com/docs/api-reference/chat",
                            "label": "üìñ API Documentation",
                            "hover": true
                        },
                        {
                            "url": "https://platform.openai.com/playground",
                            "label": "üéÆ Try in Playground",
                            "hover": true
                        }
                    ]
                },
                {
                    "word": "javascript",
                    "style": "keyword-highlight",
                    "info": `<strong>üìö JavaScript</strong><br/>High-level, interpreted programming language<br/><br/>
                    <strong>Key Features:</strong><br/>
                    ‚Ä¢ Dynamic typing<br/>
                    ‚Ä¢ First-class functions<br/>
                    ‚Ä¢ Prototype-based OOP<br/>
                    ‚Ä¢ Event-driven programming<br/><br/>
                    <strong>Popular Frameworks:</strong><br/>
                    ‚Ä¢ React, Vue, Angular (Frontend)<br/>
                    ‚Ä¢ Node.js, Express (Backend)<br/>
                    ‚Ä¢ React Native, Electron (Mobile/Desktop)<br/><br/>
                    <strong>Latest Features (ES2024):</strong><br/>
                    ‚Ä¢ Array grouping methods<br/>
                    ‚Ä¢ Promise.withResolvers()<br/>
                    ‚Ä¢ Temporal API (proposal)<br/><br/>
                    <strong>Performance Tips:</strong><br/>
                    ‚Ä¢ Use const/let instead of var<br/>
                    ‚Ä¢ Minimize DOM manipulation<br/>
                    ‚Ä¢ Leverage async/await for better readability`,
                    "actions": [
                        {
                            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript",
                            "label": "üìñ MDN Documentation",
                            "hover": true
                        },
                        {
                            "url": "https://www.ecma-international.org/ecma-262/",
                            "label": "üìã ECMAScript Specification",
                            "hover": true
                        }
                    ]
                },
                {
                    "word": "WARNING",
                    "style": "warning",
                    "info": `<strong>‚ö†Ô∏è Warning</strong><br/>Important notice that requires attention<br/><br/>
                    <strong>When to use:</strong><br/>
                    ‚Ä¢ Potential data loss scenarios<br/>
                    ‚Ä¢ Performance implications<br/>
                    ‚Ä¢ Security considerations<br/>
                    ‚Ä¢ Deprecated features<br/><br/>
                    <strong>Best practices:</strong><br/>
                    ‚Ä¢ Be specific about the risk<br/>
                    ‚Ä¢ Provide actionable solutions<br/>
                    ‚Ä¢ Use appropriate visual indicators`
                },
                {
                    "word": "SUCCESS",
                    "style": "success",
                    "info": `<strong>‚úÖ Success</strong><br/>Operation completed successfully<br/><br/>
                    <strong>Typical scenarios:</strong><br/>
                    ‚Ä¢ Data saved successfully<br/>
                    ‚Ä¢ Tests passed<br/>
                    ‚Ä¢ Deployment completed<br/>
                    ‚Ä¢ User registration confirmed<br/><br/>
                    <strong>UX considerations:</strong><br/>
                    ‚Ä¢ Provide clear confirmation<br/>
                    ‚Ä¢ Show next steps if applicable<br/>
                    ‚Ä¢ Consider auto-dismissing after delay`
                },
                {
                    "word": "TODO",
                    "style": "info",
                    "info": `<strong>‚ÑπÔ∏è Todo Item</strong><br/>Task that needs to be completed<br/><br/>
                    <strong>Best practices:</strong><br/>
                    ‚Ä¢ Be specific and actionable<br/>
                    ‚Ä¢ Include priority levels<br/>
                    ‚Ä¢ Set deadlines where appropriate<br/>
                    ‚Ä¢ Assign responsibility<br/><br/>
                    <strong>Common formats:</strong><br/>
                    ‚Ä¢ TODO: Fix bug in user authentication<br/>
                    ‚Ä¢ FIXME: Optimize database query performance<br/>
                    ‚Ä¢ HACK: Temporary workaround for API issue`
                }
            ]
        };

        require.config({ paths: { vs: 'https://unpkg.com/monaco-editor@0.44.0/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            // Generate CSS from styles map
            const style = document.createElement("style");
            let css = "";

            Object.entries(dataset.styles).forEach(([styleName, styleConfig]) => {
                css += `.monaco-editor .style-${styleName} { ${styleConfig.css} }\n`;
            });

            style.textContent = css;
            document.head.appendChild(style);

            // Extract unique trigger characters from patterns
            const triggerCharacters = [
                ...new Set(
                    dataset.patterns.map((p) => p.triggerCharacter).filter(Boolean)
                ),
            ];

            // Create the editor
            const editor = monaco.editor.create(document.getElementById('container'), {
                value: dataset.content,
                language: 'markdown',
                theme: 'vs-dark',
                fontSize: 14,
                lineNumbers: 'on',
                wordWrap: 'on',
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
                automaticLayout: true,
                lightbulb: { enabled: true },
                links: false,
                suggest: {
                    showIcons: true,
                    showSnippets: true,
                    showWords: true,
                    preview: true,
                    snippetsPreventQuickSuggestions: false,
                    showInlineDetails: true,
                    insertMode: "replace",
                    filterGraceful: true,
                    localityBonus: true,
                    shareSuggestSelections: false,
                },
                quickSuggestions: {
                    other: true,
                    comments: true,
                    strings: true,
                },
                suggestOnTriggerCharacters: true,
                acceptSuggestionOnCommitCharacter: true,
                acceptSuggestionOnEnter: 'on',
                wordBasedSuggestions: true
            });

            const disposables = [];
            let currentDecorations = [];

            // Helper function to get trigger context at position
            function getTriggerContext(model, position) {
                const line = model.getLineContent(position.lineNumber);
                const beforeCursor = line.substring(0, position.column - 1);

                // Check for trigger characters first
                let triggerChar = null;
                let triggerIndex = -1;

                for (const char of triggerCharacters) {
                    const lastIndex = beforeCursor.lastIndexOf(char);
                    if (lastIndex > triggerIndex) {
                        triggerIndex = lastIndex;
                        triggerChar = char;
                    }
                }

                if (triggerIndex !== -1) {
                    const textAfterTrigger = beforeCursor.substring(triggerIndex + 1);
                    if (!/\s/.test(textAfterTrigger)) {
                        return {
                            triggerChar,
                            triggerIndex,
                            textAfterTrigger,
                            range: {
                                startLineNumber: position.lineNumber,
                                endLineNumber: position.lineNumber,
                                startColumn: triggerIndex + 2, // +1 for 1-based, +1 to skip trigger char
                                endColumn: position.column,
                            },
                        };
                    }
                }

                // Check for regular word patterns (no trigger character)
                const word = model.getWordUntilPosition(position);
                if (word.word.length > 0) {
                    return {
                        triggerChar: null,
                        triggerIndex: -1,
                        textAfterTrigger: word.word,
                        range: {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: word.startColumn,
                            endColumn: word.endColumn,
                        },
                    };
                }

                return null;
            }

            // Enhanced autocomplete provider
            disposables.push(
                monaco.languages.registerCompletionItemProvider('markdown', {
                    triggerCharacters: [...triggerCharacters, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'],

                    provideCompletionItems: function (model, position, context) {
                        const triggerContext = getTriggerContext(model, position);

                        if (!triggerContext) {
                            return { suggestions: [] };
                        }

                        const { triggerChar, textAfterTrigger, range } = triggerContext;
                        const suggestions = [];

                        // Filter patterns based on trigger character and text matching
                        const matchingPatterns = dataset.patterns.filter(pattern => {
                            if (!pattern.word) return false;

                            // If we have a trigger character, only show patterns with matching trigger
                            if (triggerChar && pattern.triggerCharacter !== triggerChar) return false;

                            // If no trigger character, only show patterns without trigger
                            if (!triggerChar && pattern.triggerCharacter) return false;

                            // Check if pattern word matches the text after trigger
                            const isMatch = textAfterTrigger.length === 0 ||
                                pattern.word.toLowerCase().startsWith(textAfterTrigger.toLowerCase());

                            return isMatch && pattern.word !== textAfterTrigger;
                        });

                        matchingPatterns.forEach((pattern, index) => {
                            // Extract plain text from HTML for detail display
                            const plainText = pattern.info ?
                                pattern.info.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, '') : '';
                            const lines = plainText.split('\n').filter(l => l.trim());

                            suggestions.push({
                                label: {
                                    label: pattern.word,
                                    detail: lines.length > 1 ? lines[1] : '',
                                    description: lines.length > 2 ? lines.slice(2, 4).join(' ') : '',
                                },
                                kind: monaco.languages.CompletionItemKind.Text,
                                insertText: pattern.triggerComplete || pattern.word,
                                range,
                                documentation: {
                                    value: pattern.info || pattern.word,
                                    isTrusted: true,
                                    supportHtml: true
                                },
                                sortText: String(index).padStart(3, '0'),
                                filterText: pattern.word,
                                preselect: textAfterTrigger.length > 0 &&
                                    pattern.word.toLowerCase().startsWith(textAfterTrigger.toLowerCase()),
                            });
                        });

                        return { suggestions };
                    }
                })
            );

            // Enhanced hover provider
            disposables.push(
                monaco.languages.registerHoverProvider('markdown', {
                    provideHover: (model, position) => {
                        const line = model.getLineContent(position.lineNumber);

                        for (const pattern of dataset.patterns) {
                            if (!pattern.word) continue;

                            // Look for trigger + word pattern or just word
                            const searchPattern = (pattern.triggerCharacter || '') + pattern.word;
                            const index = line.indexOf(searchPattern);

                            if (index !== -1) {
                                const start = index + 1;
                                const end = start + searchPattern.length;

                                if (position.column >= start && position.column <= end) {
                                    const contents = [];

                                    if (pattern.info) {
                                        contents.push({ value: pattern.info, supportHtml: true });
                                    }

                                    if (pattern.actions) {
                                        pattern.actions
                                            .filter(action => action.hover)
                                            .forEach(action => {
                                                contents.push({
                                                    value: `[${action.label}](${action.url})`,
                                                    isTrusted: true,
                                                });
                                            });
                                    }

                                    if (contents.length > 0) {
                                        return {
                                            range: new monaco.Range(
                                                position.lineNumber,
                                                start,
                                                position.lineNumber,
                                                end
                                            ),
                                            contents: contents,
                                        };
                                    }
                                }
                            }
                        }
                    },
                })
            );

            // Enhanced link provider
            disposables.push(
                monaco.languages.registerLinkProvider('markdown', {
                    provideLinks: (model) => {
                        const lines = model.getValue().split('\n');
                        const links = [];

                        lines.forEach((line, lineIndex) => {
                            dataset.patterns.forEach((pattern) => {
                                if (!pattern.word) return;

                                const searchPattern = (pattern.triggerCharacter || '') + pattern.word;
                                let searchStart = 0;
                                let index;

                                while ((index = line.indexOf(searchPattern, searchStart)) !== -1) {
                                    const lineNumber = lineIndex + 1;
                                    const start = index + 1;
                                    const end = start + searchPattern.length;

                                    if (pattern.actions) {
                                        pattern.actions.forEach((action) => {
                                            links.push({
                                                range: new monaco.Range(lineNumber, start, lineNumber, end),
                                                url: action.url,
                                                tooltip: action.tooltip || action.label,
                                            });
                                        });
                                    }

                                    searchStart = index + 1;
                                }
                            });
                        });

                        return { links };
                    },
                })
            );

            // Quick fixes for replacements
            disposables.push(
                monaco.languages.registerCodeActionProvider('markdown', {
                    provideCodeActions: (model, range) => {
                        const line = model.getLineContent(range.startLineNumber);
                        const actions = [];

                        dataset.patterns.forEach((pattern) => {
                            if (pattern.errorReplace && pattern.errorLabel && pattern.word) {
                                const searchPattern = (pattern.triggerCharacter || '') + pattern.word;
                                const index = line.indexOf(searchPattern);

                                if (index !== -1) {
                                    const start = index + 1;
                                    const end = start + searchPattern.length;

                                    if (range.startColumn >= start && range.endColumn <= end) {
                                        actions.push({
                                            title: pattern.errorLabel,
                                            kind: 'quickfix',
                                            edit: {
                                                edits: [
                                                    {
                                                        resource: model.uri,
                                                        textEdit: {
                                                            range: {
                                                                startLineNumber: range.startLineNumber,
                                                                startColumn: start,
                                                                endLineNumber: range.endLineNumber,
                                                                endColumn: end,
                                                            },
                                                            text: pattern.errorReplace,
                                                        },
                                                    },
                                                ],
                                            },
                                        });
                                    }
                                }
                            }
                        });

                        return { actions, dispose: () => { } };
                    },
                })
            );

            // Enhanced code lens
            disposables.push(
                monaco.languages.registerCodeLensProvider('markdown', {
                    provideCodeLenses: (model) => {
                        const lines = model.getValue().split('\n');
                        const lenses = [];

                        lines.forEach((line, lineIndex) => {
                            dataset.patterns.forEach((pattern) => {
                                if (!pattern.word) return;

                                const searchPattern = (pattern.triggerCharacter || '') + pattern.word;
                                const index = line.indexOf(searchPattern);

                                if (index !== -1) {
                                    const range = {
                                        startLineNumber: lineIndex + 1,
                                        startColumn: index + 1,
                                        endLineNumber: lineIndex + 1,
                                        endColumn: index + searchPattern.length + 1,
                                    };

                                    if (pattern.actions && pattern.actions.length > 0) {
                                        pattern.actions.forEach((action) => {
                                            if (action.tooltip) {
                                                lenses.push({
                                                    range,
                                                    command: {
                                                        id: 'openUrl',
                                                        title: action.label,
                                                        arguments: [action.url],
                                                        tooltip: action.label,
                                                    },
                                                });
                                            }
                                        });
                                    }
                                }
                            });
                        });

                        return { lenses, dispose: () => { } };
                    },
                })
            );

            // URL opener command
            monaco.editor.addCommand({
                id: 'openUrl',
                run: (_, url) => window.open(url, '_blank'),
            });

            // Apply decorations with proper cleanup
            const updateDecorations = () => {
                const model = editor.getModel();
                const lines = model.getValue().split('\n');
                const decorations = [];
                const markers = [];
                let inCodeBlock = false;

                lines.forEach((line, lineIndex) => {
                    if (line.trim().startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        return;
                    }
                    if (inCodeBlock) return;

                    dataset.patterns.forEach((pattern) => {
                        if (!pattern.word) return;

                        const searchPattern = (pattern.triggerCharacter || '') + pattern.word;
                        let searchStart = 0;
                        let index;

                        while ((index = line.indexOf(searchPattern, searchStart)) !== -1) {
                            const lineNumber = lineIndex + 1;
                            const start = index + 1;
                            const end = start + searchPattern.length;

                            // Apply main decoration
                            decorations.push({
                                range: new monaco.Range(lineNumber, start, lineNumber, end),
                                options: { inlineClassName: `style-${pattern.style}` },
                            });

                            // Add markers for errors
                            if (pattern.errorReplace && pattern.errorSeverity) {
                                const severity =
                                    pattern.errorSeverity === 'error'
                                        ? monaco.MarkerSeverity.Error
                                        : pattern.errorSeverity === 'warning'
                                            ? monaco.MarkerSeverity.Warning
                                            : monaco.MarkerSeverity.Info;

                                markers.push({
                                    startLineNumber: lineNumber,
                                    startColumn: start,
                                    endLineNumber: lineNumber,
                                    endColumn: end,
                                    message: pattern.errorLabel || `Issue with: ${searchPattern}`,
                                    severity: severity,
                                });
                            }

                            searchStart = index + 1;
                        }
                    });
                });

                currentDecorations = editor.deltaDecorations(currentDecorations, decorations);
                monaco.editor.setModelMarkers(model, 'patterns', markers);
            };

            // Auto-trigger suggestions on typing with proper delay
            let typingTimer;

            editor.onDidChangeModelContent((e) => {
                clearTimeout(typingTimer);
                typingTimer = setTimeout(() => {
                    const position = editor.getPosition();
                    const model = editor.getModel();
                    const triggerContext = getTriggerContext(model, position);

                    // Trigger if we have a valid trigger context
                    if (triggerContext && triggerContext.textAfterTrigger.length > 0) {
                        const matchingPatterns = dataset.patterns.filter(pattern => {
                            if (!pattern.word) return false;

                            const triggerMatches = triggerContext.triggerChar ?
                                pattern.triggerCharacter === triggerContext.triggerChar :
                                !pattern.triggerCharacter;

                            const wordMatches = pattern.word.toLowerCase()
                                .startsWith(triggerContext.textAfterTrigger.toLowerCase()) &&
                                pattern.word !== triggerContext.textAfterTrigger;

                            return triggerMatches && wordMatches;
                        });

                        if (matchingPatterns.length > 0) {
                            editor.trigger('auto', 'editor.action.triggerSuggest', {});
                        }
                    }

                    // Update decorations
                    updateDecorations();
                }, 150);
            });

            // Manual trigger with Ctrl+Space
            editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Space, () => {
                editor.trigger('manual', 'editor.action.triggerSuggest', {});
            });

            // CRUCIAL: Set details visible by default for auto-expanded behavior
            setTimeout(() => {
                try {
                    const suggestController = editor.getContribution('editor.contrib.suggestController');
                    if (suggestController && suggestController.widget && suggestController.widget.value) {
                        suggestController.widget.value._setDetailsVisible(true);
                    }
                } catch (e) {
                    console.log('Could not auto-expand suggestions details:', e);
                }
            }, 100);

            // Also try to expand details whenever suggestions are triggered
            editor.onDidTriggerSuggest(() => {
                setTimeout(() => {
                    try {
                        const suggestController = editor.getContribution('editor.contrib.suggestController');
                        if (suggestController && suggestController.widget && suggestController.widget.value) {
                            suggestController.widget.value._setDetailsVisible(true);
                        }
                    } catch (e) {
                        console.log('Could not auto-expand suggestions details on trigger:', e);
                    }
                }, 50);
            });

            // Initial decoration update
            setTimeout(updateDecorations, 100);

            // Auto-resize editor on window resize
            window.addEventListener('resize', () => {
                editor.layout();
            });

            // Focus the editor
            editor.focus();

            // Cleanup function
            window.addEventListener('beforeunload', () => {
                disposables.forEach((d) => d.dispose());
            });
        });
    </script>
</body>

</html>