<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Pattern Monaco Editor</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #container {
            width: 100%;
            height: 600px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üéØ Simple Pattern Editor</h1>
        <p>JSON-driven Monaco enhancement</p>
    </div>

    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
    <script>
        const dataset = {
            "styles": {
                "spelling-error": {
                    "css": "text-decoration: underline wavy red !important;",
                },
                "user-mention": {
                    "css": "color: #1da1f2 !important; background: rgba(29,161,242,0.1) !important; padding: 1px 2px !important; border-radius: 3px !important;",
                },
                "api-endpoint": {
                    "css": "color: #ff6b35 !important; text-decoration: underline !important;",
                },
                "token-count": {
                    "css": "color: #ffa500 !important;",
                },
                "keyword-highlight": {
                    "css": "color: #00ff88 !important; background: rgba(0,255,136,0.1) !important; padding: 1px 2px !important; border-radius: 3px !important;",
                },
                "warning": {
                    "css": "background: rgba(255,193,7,0.2) !important; border-left: 3px solid #ffc107 !important; padding: 1px 4px !important;",
                },
                "success": {
                    "css": "background: rgba(40,167,69,0.2) !important; border-left: 3px solid #28a745 !important; padding: 1px 4px !important;",
                },
                "info": {
                    "css": "background: rgba(23,162,184,0.2) !important; border-left: 3px solid #17a2b8 !important; padding: 1px 4px !important;",
                }
            },
            "patterns": [
                {
                    "word": "recieve",
                    "style": "spelling-error",
                    "errorLabel": "Fix to 'receive'",
                    "errorReplace": "receive",
                    "errorSeverity": "error"
                },
                {
                    "word": "teh",
                    "style": "spelling-error",
                    "errorLabel": "Fix to 'the'",
                    "errorReplace": "the",
                    "errorSeverity": "error"
                },
                {
                    "word": "@johndoe",
                    "style": "user-mention",
                    "info": "<strong>üë§ John Doe</strong><br/>Software Developer<br/>üìä 2.3K followers",
                    "actions": [
                        {
                            "url": "https://twitter.com/johndoe",
                            "label": "üê¶ Open Twitter Profile",
                            "hover": true,
                            //   "tooltip": true
                        },
                        {
                            "url": "https://linkedin.com/in/johndoe",
                            "label": "üíº LinkedIn Profile",
                            "hover": true,
                            //  "tooltip": false
                        },
                        {
                            "url": "https://github.com/johndoe",
                            "label": "üêô GitHub Profile",
                            "hover": false,
                            //  "tooltip": true
                        }
                    ]
                },
                {
                    "word": "https://api.openai.com/v1/chat/completions",
                    "style": "token-count",
                    "info": "<strong>üåê OpenAI Chat API</strong><br/>POST endpoint<br/>‚ö° ~150 tokens",
                    "actions": [
                        {
                            "url": "https://platform.openai.com/docs/api-reference/chat",
                            "label": "üìñ API Documentation",
                            "hover": true,
                            //   "tooltip": true
                        },
                        {
                            "url": "https://platform.openai.com/playground",
                            "label": "üéÆ Try in Playground",
                            "hover": true,
                            //  "tooltip": true
                        },
                        {
                            "url": "https://platform.openai.com/usage",
                            "label": "üìä Usage Dashboard",
                            "hover": false,
                            //"tooltip": true
                        }
                    ]
                },
                {
                    "word": "javascript",
                    "style": "keyword-highlight",
                    "info": "<strong>üìö JavaScript</strong><br/>High-level programming language",
                    "actions": [
                        {
                            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript",
                            "label": "üìñ MDN Documentation",
                            "hover": true,
                            //  "tooltip": true
                        },
                        {
                            "url": "https://www.javascript.com/",
                            "label": "üåê JavaScript.com",
                            "hover": true,
                            // "tooltip": false
                        }
                    ]
                },
                {
                    "word": "WARNING",
                    "style": "warning",
                    "info": "<strong>‚ö†Ô∏è Warning</strong><br/>Important notice that requires attention"
                },
                {
                    "word": "SUCCESS",
                    "style": "success",
                    "info": "<strong>‚úÖ Success</strong><br/>Operation completed successfully"
                },
                {
                    "word": "TODO",
                    "style": "info",
                    "info": "<strong>‚ÑπÔ∏è Todo Item</strong><br/>Task that needs to be completed"
                }
            ]
        };

        require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            // Generate CSS from styles map
            const style = document.createElement('style');
            let css = '';

            // Generate base classes from styles
            Object.entries(dataset.styles).forEach(([styleName, styleConfig]) => {
                css += `.monaco-editor .style-${styleName} { ${styleConfig.css} }`;
            });

            style.textContent = css;
            document.head.appendChild(style);

            const editor = monaco.editor.create(document.getElementById('container'), {
                value: `# Pattern Editor Demo

I always recieve emails, but teh system is slow.
Great work by @johndoe on the project!
Check out: https://api.openai.com/v1/chat/completions
We use **javascript** for development.

WARNING: This is a warning message
SUCCESS: Operation completed successfully  
TODO: Add more examples`,
                language: 'markdown',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                wordWrap: 'on',
                lightbulb: { enabled: true },
                // Disable automatic link detection to prevent conflicts
                links: false,
                // Enable suggestions
                suggest: {
                    showIcons: true,
                    showSnippets: true,
                    showWords: true,
                    showKeywords: true,
                    insertMode: 'replace',
                    filterGraceful: true,
                    snippetsPreventQuickSuggestions: false,
                    localityBonus: true,
                    shareSuggestSelections: false,
                }
            });

            const disposables = [];
            let currentDecorations = []; // Track current decorations

            // Helper function to get word at position with better boundary detection
            function getWordAtPosition(model, position) {
                const line = model.getLineContent(position.lineNumber);
                const wordSeparators = /[\s\.,;:!?\(\)\[\]{}"'`~@#$%^&*+=|\\<>\/]/;

                let start = position.column - 1;
                let end = position.column - 1;

                // Find start of word
                while (start > 0 && !wordSeparators.test(line[start - 1])) {
                    start--;
                }

                // Find end of word
                while (end < line.length && !wordSeparators.test(line[end])) {
                    end++;
                }

                const word = line.substring(start, end);
                const currentText = line.substring(start, position.column - 1);

                return {
                    word,
                    currentText,
                    range: {
                        startLineNumber: position.lineNumber,
                        endLineNumber: position.lineNumber,
                        startColumn: start + 1,
                        endColumn: end + 1,
                    }
                };
            }

            // Custom autocomplete provider
            disposables.push(monaco.languages.registerCompletionItemProvider('markdown', {
                triggerCharacters: ['@', 'h', 't', 'r', 'j', 'W', 'S', 'T'], // First chars of patterns

                provideCompletionItems: (model, position, context) => {
                    const { currentText, range } = getWordAtPosition(model, position);
                    const suggestions = [];

                    // Always show suggestions if manually triggered or if we have matching text
                    const showSuggestions = context.triggerKind === monaco.languages.CompletionTriggerKind.Invoke ||
                        currentText.length > 0;

                    if (!showSuggestions) {
                        return { suggestions: [] };
                    }

                    // Find matching patterns
                    dataset.patterns.forEach((pattern, index) => {
                        // Match if:
                        // 1. Manual trigger (Ctrl+Space)
                        // 2. Pattern starts with current text
                        // 3. Pattern contains current text (for partial matches)
                        const isMatch = currentText.length === 0 ||
                            pattern.word.toLowerCase().startsWith(currentText.toLowerCase()) ||
                            (currentText.length >= 2 && pattern.word.toLowerCase().includes(currentText.toLowerCase()));

                        if (isMatch) {
                            // Extract plain text from HTML for detail display
                            const plainText = pattern.info ? pattern.info.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, '') : '';
                            const lines = plainText.split('\n').filter(l => l.trim());

                            suggestions.push({
                                label: {
                                    label: pattern.word,
                                    detail: lines.length > 1 ? lines[1] : '', // Second line as detail
                                    description: lines.length > 2 ? lines.slice(2).join(' ') : '' // Rest as description
                                },
                                kind: monaco.languages.CompletionItemKind.Text,
                                insertText: pattern.word,
                                range,
                                documentation: {
                                    value: pattern.info || pattern.word,
                                    isTrusted: true
                                },
                                sortText: String(index).padStart(3, '0'),
                                filterText: pattern.word,
                                preselect: currentText.length > 0 && pattern.word.toLowerCase().startsWith(currentText.toLowerCase())
                            });
                        }
                    });

                    return {
                        suggestions,
                        incomplete: currentText.length > 0 && suggestions.length === 0 // Keep searching if no matches yet
                    };
                }
            }));

            // Auto-trigger suggestions on typing
            let typingTimer;
            editor.onDidChangeModelContent((e) => {
                clearTimeout(typingTimer);
                typingTimer = setTimeout(() => {
                    const position = editor.getPosition();
                    const model = editor.getModel();
                    const { currentText } = getWordAtPosition(model, position);

                    // Trigger if we have text and it could match a pattern
                    if (currentText.length > 0) {
                        const hasMatches = dataset.patterns.some(pattern =>
                            pattern.word.toLowerCase().startsWith(currentText.toLowerCase()) ||
                            (currentText.length >= 2 && pattern.word.toLowerCase().includes(currentText.toLowerCase()))
                        );

                        if (hasMatches) {
                            editor.trigger('auto', 'editor.action.triggerSuggest', {});
                        }
                    }

                    // Update decorations
                    updateDecorations();
                }, 150);
            });

            // Manual trigger with Ctrl+Space
            editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Space, () => {
                editor.trigger('manual', 'editor.action.triggerSuggest', {});
            });

            // Enhanced hover provider with multiple actions support
            disposables.push(monaco.languages.registerHoverProvider('markdown', {
                provideHover: (model, position) => {
                    const line = model.getLineContent(position.lineNumber);

                    for (const pattern of dataset.patterns) {
                        const index = line.indexOf(pattern.word);
                        if (index !== -1) {
                            const start = index + 1;
                            const end = start + pattern.word.length;

                            if (position.column >= start && position.column <= end) {
                                const contents = [];

                                // Add main info if it exists
                                if (pattern.info) {
                                    contents.push({ value: pattern.info, supportHtml: true });
                                }

                                // Add hover-enabled actions
                                if (pattern.actions) {
                                    pattern.actions.filter(action => action.hover).map(action => {

                                        contents.push({
                                            value: `[${action.label}](${action.url})`,
                                            isTrusted: true
                                        });

                                    })


                                }

                                if (contents.length > 0) {
                                    return {
                                        range: new monaco.Range(position.lineNumber, start, position.lineNumber, end),
                                        contents: contents
                                    };
                                }
                            }
                        }
                    }
                }
            }));

            // Enhanced link provider with multiple actions support
            disposables.push(monaco.languages.registerLinkProvider('markdown', {
                provideLinks: (model) => {
                    const lines = model.getValue().split('\n');
                    const links = [];

                    lines.forEach((line, lineIndex) => {
                        dataset.patterns.forEach(pattern => {
                            let searchStart = 0;
                            let index;

                            // Find all occurrences of the pattern in the line
                            while ((index = line.indexOf(pattern.word, searchStart)) !== -1) {
                                const lineNumber = lineIndex + 1;
                                const start = index + 1;
                                const end = start + pattern.word.length;

                                // Handle new actions array format
                                if (pattern.actions) {
                                    // For now, use the first action for the primary link
                                    // In a real implementation, you might want to show a context menu
                                    const primaryAction = pattern.actions[0];

                                    pattern.actions.map(action => {
                                        links.push({
                                            range: new monaco.Range(lineNumber, start, lineNumber, end),
                                            url: action.url,
                                            tooltip: action.tooltip ? action.label : undefined
                                        });
                                    })

                                }

                                searchStart = index + 1;
                            }
                        });
                    });

                    return { links };
                }
            }));

            // Quick fixes for replacements
            disposables.push(monaco.languages.registerCodeActionProvider('markdown', {
                provideCodeActions: (model, range) => {
                    const line = model.getLineContent(range.startLineNumber);
                    const actions = [];

                    dataset.patterns.forEach(pattern => {
                        // Check if pattern has error replacement
                        if (pattern.errorReplace && pattern.errorLabel) {
                            const index = line.indexOf(pattern.word);
                            if (index !== -1) {
                                const start = index + 1;
                                const end = start + pattern.word.length;

                                if (range.startColumn >= start && range.endColumn <= end) {
                                    actions.push({
                                        title: pattern.errorLabel,
                                        kind: 'quickfix',
                                        edit: {
                                            edits: [{
                                                resource: model.uri,
                                                textEdit: {
                                                    range: {
                                                        startLineNumber: range.startLineNumber,
                                                        startColumn: start,
                                                        endLineNumber: range.endLineNumber,
                                                        endColumn: end
                                                    },
                                                    text: pattern.errorReplace
                                                }
                                            }]
                                        }
                                    });
                                }
                            }
                        }
                    });

                    return { actions, dispose: () => { } };
                }
            }));

            // Enhanced code lens with multiple actions support
            disposables.push(monaco.languages.registerCodeLensProvider('markdown', {
                provideCodeLenses: (model) => {
                    const lines = model.getValue().split('\n');
                    const lenses = [];

                    lines.forEach((line, lineIndex) => {
                        dataset.patterns.forEach((pattern, patternIndex) => {
                            const index = line.indexOf(pattern.word);
                            if (index !== -1) {
                                const range = {
                                    startLineNumber: lineIndex + 1,
                                    startColumn: index + 1,
                                    endLineNumber: lineIndex + 1,
                                    endColumn: index + pattern.word.length + 1
                                };

                                // Handle new actions array format
                                if (pattern.actions && pattern.actions.length > 0) {
                                    // Create a lens for each action, or combine them
                                    pattern.actions.forEach((action, actionIndex) => {
                                        if (action.tooltip) {
                                            lenses.push({
                                                range,
                                                command: {
                                                    id: 'openUrl',
                                                    title: action.label,
                                                    arguments: [action.url],
                                                    tooltip: action.label
                                                }
                                            });
                                        }

                                    });
                                }
                            }
                        });
                    });

                    return { lenses, dispose: () => { } };
                }
            }));

            // URL opener command
            monaco.editor.addCommand({
                id: 'openUrl',
                run: (_, url) => window.open(url, '_blank')
            });

            // Apply decorations with proper cleanup
            const updateDecorations = () => {
                const model = editor.getModel();
                const lines = model.getValue().split('\n');
                const decorations = [];
                const markers = [];
                let inCodeBlock = false;

                lines.forEach((line, lineIndex) => {
                    if (line.trim().startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        return;
                    }
                    if (inCodeBlock) return;

                    dataset.patterns.forEach((pattern) => {
                        let searchStart = 0;
                        let index;

                        // Find all occurrences of the pattern in the line
                        while ((index = line.indexOf(pattern.word, searchStart)) !== -1) {
                            const lineNumber = lineIndex + 1;
                            const start = index + 1;
                            const end = start + pattern.word.length;

                            // Apply main decoration
                            decorations.push({
                                range: new monaco.Range(lineNumber, start, lineNumber, end),
                                options: { inlineClassName: `style-${pattern.style}` }
                            });

                            // Add markers for errors
                            if (pattern.errorReplace && pattern.errorSeverity) {
                                const severity = pattern.errorSeverity === 'error' ? monaco.MarkerSeverity.Error :
                                    pattern.errorSeverity === 'warning' ? monaco.MarkerSeverity.Warning :
                                        monaco.MarkerSeverity.Info;

                                markers.push({
                                    startLineNumber: lineNumber,
                                    startColumn: start,
                                    endLineNumber: lineNumber,
                                    endColumn: end,
                                    message: pattern.errorLabel || `Issue with: ${pattern.word}`,
                                    severity: severity
                                });
                            }

                            searchStart = index + 1;
                        }
                    });
                });

                // Properly clear old decorations before applying new ones
                currentDecorations = editor.deltaDecorations(currentDecorations, decorations);
                monaco.editor.setModelMarkers(model, 'patterns', markers);
            };

            // Initial decoration update
            setTimeout(updateDecorations, 100);

            // Cleanup function
            window.addEventListener('beforeunload', () => {
                disposables.forEach(d => d.dispose());
            });
        });
    </script>
</body>

</html>