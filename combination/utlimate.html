<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Editor - Ultimate Markdown Edition</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            margin: 10px 0;
            opacity: 0.9;
        }

        .features {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .features h3 {
            margin-top: 0;
            color: #ffd700;
        }

        .features ul {
            columns: 2;
            column-gap: 30px;
        }

        .features li {
            margin-bottom: 8px;
            break-inside: avoid;
        }

        #container {
            width: 100%;
            height: 600px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        /* Custom styling for various features */
        .spelling-error {
            text-decoration: underline wavy red !important;
        }

        .username-highlight {
            color: #1da1f2 !important;
            font-weight: bold !important;
            background: rgba(29, 161, 242, 0.1) !important;
            padding: 1px 2px !important;
            border-radius: 3px !important;
        }

        .vocab-word {
            color: #00ff88 !important;
            font-weight: bold !important;
            background: rgba(0, 255, 136, 0.1) !important;
            padding: 1px 2px !important;
            border-radius: 3px !important;
        }

        .url-label {
            background: #ff6b35 !important;
            color: white !important;
            padding: 2px 6px !important;
            border-radius: 12px !important;
            font-size: 10px !important;
            font-weight: bold !important;
            margin-left: 5px !important;
        }

        .monaco-editor .codelens-decoration>span {
            margin-right: 8px !important;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>ğŸš€ Monaco Editor Ultimate</h1>
        <p>The most powerful markdown editor with AI-powered features</p>
    </div>

    <div class="features">
        <h3>âœ¨ Integrated Features</h3>
        <ul>
            <li><strong>ğŸ”¤ Spell Check:</strong> Real-time spelling corrections with lightbulb fixes</li>
            <li><strong>ğŸŒ URL Intellisense:</strong> Smart URL completions with metadata</li>
            <li><strong>ğŸ‘¤ @Username Mentions:</strong> Autocomplete with user profiles and social links</li>
            <li><strong>ğŸ“š Custom Vocabulary:</strong> Programming terms with definitions</li>
            <li><strong>ğŸ’¡ CodeLens Actions:</strong> Quick actions for usernames and URLs</li>
            <li><strong>ğŸ¯ Hover Information:</strong> Rich tooltips for all enhanced elements</li>
            <li><strong>ğŸ¨ Smart Highlighting:</strong> Color-coded elements for better readability</li>
            <li><strong>âš¡ Live Updates:</strong> All features work in real-time as you type</li>
        </ul>
    </div>

    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
    <script>
        require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            // ===== DATABASES =====

            // Spelling corrections database
            const spellCorrections = {
                'recieve': 'receive', 'occured': 'occurred', 'seperate': 'separate',
                'definately': 'definitely', 'accomodate': 'accommodate', 'necesary': 'necessary',
                'embarass': 'embarrass', 'tommorow': 'tomorrow', 'misspeled': 'misspelled',
                'writting': 'writing', 'begining': 'beginning', 'comming': 'coming',
                'runing': 'running', 'geting': 'getting', 'puting': 'putting',
                'makeing': 'making', 'changeing': 'changing', 'moveing': 'moving',
                'exmaple': 'example', 'featuers': 'features', 'dictonary': 'dictionary',
                'sugestions': 'suggestions', 'variabled': 'variable', 'wrold': 'world',
                'demontrates': 'demonstrates', 'powerfull': 'powerful', 'editng': 'editing',
                'sophistcated': 'sophisticated', 'teh': 'the', 'adn': 'and',
                'taht': 'that', 'thier': 'their', 'youre': "you're",
                'cant': "can't", 'wont': "won't", 'dont': "don't"
            };

            // URL database with metadata
            const urlDatabase = {
                'https://api.openai.com/v1/chat/completions': {
                    tokens: 150, description: 'OpenAI Chat Completions API endpoint', method: 'POST'
                },
                'https://api.github.com/repos': {
                    tokens: 50, description: 'GitHub Repositories API', method: 'GET'
                },
                'https://jsonplaceholder.typicode.com/posts': {
                    tokens: 75, description: 'JSONPlaceholder Posts API for testing', method: 'GET'
                },
                'https://api.anthropic.com/v1/messages': {
                    tokens: 120, description: 'Anthropic Messages API endpoint', method: 'POST'
                },
                'https://api.cohere.ai/v1/generate': {
                    tokens: 90, description: 'Cohere Text Generation API', method: 'POST'
                }
            };

            // Username database with profiles
            const usernameDatabase = {
                'johndoe': {
                    name: 'John Doe', bio: 'Software Developer at TechCorp',
                    followers: '2.3K', avatar: 'https://randomuser.me/api/portraits/men/1.jpg', verified: true
                },
                'janedeveloper': {
                    name: 'Jane Developer', bio: 'Full Stack Engineer & Open Source Contributor',
                    followers: '5.7K', avatar: 'https://randomuser.me/api/portraits/women/2.jpg', verified: false
                },
                'techguru': {
                    name: 'Tech Guru', bio: 'Technology Enthusiast & Blogger',
                    followers: '12.1K', avatar: 'https://randomuser.me/api/portraits/men/3.jpg', verified: true
                },
                'codemaster': {
                    name: 'Code Master', bio: 'Senior Software Architect',
                    followers: '8.9K', avatar: 'https://randomuser.me/api/portraits/women/4.jpg', verified: false
                },
                'aiexpert': {
                    name: 'AI Expert', bio: 'Machine Learning Engineer & AI Researcher',
                    followers: '9.8K', avatar: 'https://randomuser.me/api/portraits/men/7.jpg', verified: true
                }
            };

            // Programming vocabulary with definitions
            const vocabulary = {
                'javascript': 'A high-level, interpreted programming language that conforms to the ECMAScript specification.',
                'python': 'A high-level, interpreted programming language with dynamic semantics and simple syntax.',
                'react': 'A JavaScript library for building user interfaces, maintained by Facebook.',
                'nodejs': 'A JavaScript runtime built on Chrome\'s V8 JavaScript engine for server-side development.',
                'typescript': 'A strongly typed programming language that builds on JavaScript by adding static type definitions.',
                'mongodb': 'A document-oriented NoSQL database program that uses JSON-like documents with optional schemas.',
                'docker': 'A platform for developing, shipping, and running applications using containerization technology.',
                'kubernetes': 'An open-source container orchestration platform for automating deployment and management.',
                'git': 'A distributed version control system for tracking changes in source code during software development.',
                'github': 'A web-based hosting service for version control using Git, owned by Microsoft.'
            };

            // ===== INITIAL CONTENT =====
            const initialContent = `# ğŸš€ Ultimate Monaco Editor Demo

Welcome to the most **powerfull** markdown editor! This demontrates all featuers in one place.

## ğŸ‘¥ Team Mentions

Great work on the project! Shoutout to @johndoe for the excellent **javascript** backend work.
Also want to thank @janedeveloper for the amazing **react** frontend components.

Looking forward to collaboration with @techguru and @codemaster on the **nodejs** API.

## ğŸŒ API Resources

Here are some useful APIs for development:

- [OpenAI API](https://api.openai.com/v1/chat/completions) - Perfect for AI integrations
- [GitHub API](https://api.github.com/repos) - Access repository data
- Raw URL: https://jsonplaceholder.typicode.com/posts

## ğŸ’» Technology Stack

Our project uses modern technologies like **typescript**, **mongodb**, and **docker**.
We also utilize **kubernetes** for orchestration and **git** for version control.

## ğŸ¯ Interactive Features

Try these features:
- Type "https://" to see URL completions
- Type "@" to see user suggestions  
- Hover over blue words for definitions
- Click the lightbulb icon to fix misspeled words
- Use CodeLens actions on usernames and URLs

### Code Example

\`\`\`javascript
// This is a code block - words here shouldn't be spell checked
const myVarible = "Hello Wrold";
console.log(myVarible);
\`\`\`

Happy editng! ğŸ‰
`;

            // ===== EDITOR CREATION =====
            const editor = monaco.editor.create(document.getElementById('container'), {
                value: initialContent,
                language: 'markdown',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                wordWrap: 'on',
                lightbulb: { enabled: true },
                codeLens: true,
                fontSize: 14,
                lineHeight: 22,
                padding: { top: 20, bottom: 20 }
            });

            // ===== COMPLETION PROVIDERS =====

            // URL Completion Provider
            monaco.languages.registerCompletionItemProvider('markdown', {
                provideCompletionItems: function (model, position) {
                    const textUntilPosition = model.getValueInRange({
                        startLineNumber: position.lineNumber,
                        startColumn: 1,
                        endLineNumber: position.lineNumber,
                        endColumn: position.column
                    });

                    const suggestions = [];

                    // URL completions
                    const urlMatch = textUntilPosition.match(/https?:\/\/[\w.-]*$/);
                    if (urlMatch) {
                        const word = model.getWordUntilPosition(position);
                        const range = {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: position.column - urlMatch[0].length + urlMatch[0].indexOf('://') + 3,
                            endColumn: word.endColumn
                        };

                        Object.keys(urlDatabase).forEach(url => {
                            const urlInfo = urlDatabase[url];
                            suggestions.push({
                                label: url,
                                kind: monaco.languages.CompletionItemKind.Reference,
                                insertText: url,
                                range: range,
                                detail: `${urlInfo.method} - ${urlInfo.tokens} tokens`,
                                documentation: {
                                    value: `**${urlInfo.description}**\n\nEstimated tokens: ${urlInfo.tokens}\nMethod: ${urlInfo.method}`
                                }
                            });
                        });
                    }

                    // Username completions
                    const atMatch = textUntilPosition.match(/@(\w*)$/);
                    if (atMatch) {
                        const word = model.getWordUntilPosition(position);
                        const range = {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: position.column - atMatch[1].length,
                            endColumn: word.endColumn
                        };

                        Object.keys(usernameDatabase).forEach(username => {
                            const user = usernameDatabase[username];
                            suggestions.push({
                                label: `@${username}`,
                                kind: monaco.languages.CompletionItemKind.User,
                                insertText: username,
                                range: range,
                                detail: `${user.name} â€¢ ${user.followers} followers`,
                                documentation: {
                                    value: `**${user.name}** ${user.verified ? 'âœ“' : ''}\n\n${user.bio}\n\n**Followers:** ${user.followers}`
                                }
                            });
                        });
                    }

                    // Vocabulary completions
                    const word = model.getWordUntilPosition(position);
                    if (word.word.length > 0) {
                        const range = {
                            startLineNumber: position.lineNumber,
                            endLineNumber: position.lineNumber,
                            startColumn: word.startColumn,
                            endColumn: word.endColumn
                        };

                        Object.keys(vocabulary).forEach(vocabWord => {
                            if (vocabWord.toLowerCase().startsWith(word.word.toLowerCase())) {
                                suggestions.push({
                                    label: vocabWord,
                                    kind: monaco.languages.CompletionItemKind.Keyword,
                                    insertText: vocabWord,
                                    range: range,
                                    detail: 'Programming Term',
                                    documentation: vocabulary[vocabWord]
                                });
                            }
                        });
                    }

                    return { suggestions };
                }
            });

            // ===== HOVER PROVIDER =====
            monaco.languages.registerHoverProvider('markdown', {
                provideHover: function (model, position) {
                    const line = model.getLineContent(position.lineNumber);

                    // Check for URLs
                    const urlRegex = /https?:\/\/[^\s\)]+/g;
                    let urlMatch;
                    while ((urlMatch = urlRegex.exec(line)) !== null) {
                        const startColumn = urlMatch.index + 1;
                        const endColumn = startColumn + urlMatch[0].length;

                        if (position.column >= startColumn && position.column <= endColumn) {
                            const url = urlMatch[0];
                            const urlInfo = urlDatabase[url];

                            if (urlInfo) {
                                return {
                                    range: new monaco.Range(position.lineNumber, startColumn, position.lineNumber, endColumn),
                                    contents: [
                                        { value: `**ğŸŒ ${url}**` },
                                        { value: urlInfo.description },
                                        { value: `**Method:** ${urlInfo.method} | **Tokens:** ${urlInfo.tokens}` }
                                    ]
                                };
                            }
                        }
                    }

                    // Check for usernames
                    const usernameRegex = /@(\w+)/g;
                    let usernameMatch;
                    while ((usernameMatch = usernameRegex.exec(line)) !== null) {
                        const startColumn = usernameMatch.index + 1;
                        const endColumn = startColumn + usernameMatch[0].length;

                        if (position.column >= startColumn && position.column <= endColumn) {
                            const username = usernameMatch[1];
                            const userInfo = usernameDatabase[username];

                            if (userInfo) {
                                return {
                                    range: new monaco.Range(position.lineNumber, startColumn, position.lineNumber, endColumn),
                                    contents: [
                                        { value: `**ğŸ‘¤ @${username}** ${userInfo.verified ? 'âœ…' : ''}` },
                                        { value: `![Avatar](${userInfo.avatar})` },
                                        { value: `**${userInfo.name}**` },
                                        { value: userInfo.bio },
                                        { value: `**Followers:** ${userInfo.followers}` }
                                    ]
                                };
                            }
                        }
                    }

                    // Check for vocabulary words
                    const word = model.getWordAtPosition(position);
                    if (word) {
                        const wordText = word.word.toLowerCase();
                        if (vocabulary[wordText]) {
                            return {
                                range: new monaco.Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn),
                                contents: [
                                    { value: `**ğŸ“š ${wordText}**` },
                                    { value: vocabulary[wordText] },
                                    { value: '_Programming vocabulary term_' }
                                ]
                            };
                        }
                    }

                    return null;
                }
            });

            // ===== CODE ACTION PROVIDER (SPELL CHECKING) =====
            monaco.languages.registerCodeActionProvider('markdown', {
                provideCodeActions: function (model, range, context) {
                    const actions = [];
                    const markers = monaco.editor.getModelMarkers({
                        resource: model.uri
                    }).filter(marker =>
                        marker.startLineNumber <= range.endLineNumber &&
                        marker.endLineNumber >= range.startLineNumber &&
                        marker.code === 'spelling'
                    );

                    markers.forEach(marker => {
                        const word = model.getValueInRange({
                            startLineNumber: marker.startLineNumber,
                            startColumn: marker.startColumn,
                            endLineNumber: marker.endLineNumber,
                            endColumn: marker.endColumn
                        });

                        const correction = spellCorrections[word.toLowerCase()];
                        if (correction) {
                            actions.push({
                                title: `âœ¨ Fix: ${word} â†’ ${correction}`,
                                kind: 'quickfix',
                                edit: {
                                    edits: [{
                                        resource: model.uri,
                                        textEdit: {
                                            range: {
                                                startLineNumber: marker.startLineNumber,
                                                startColumn: marker.startColumn,
                                                endLineNumber: marker.endLineNumber,
                                                endColumn: marker.endColumn
                                            },
                                            text: correction
                                        }
                                    }]
                                }
                            });
                        }
                    });

                    return { actions, dispose: () => { } };
                }
            });

            // ===== CODE LENS PROVIDER =====
            monaco.languages.registerCodeLensProvider('markdown', {
                provideCodeLenses: function (model) {
                    const lenses = [];
                    const text = model.getValue();
                    const lines = text.split('\n');

                    lines.forEach((line, lineIndex) => {
                        // Username lenses
                        const usernameRegex = /@(\w+)/g;
                        let usernameMatch;
                        while ((usernameMatch = usernameRegex.exec(line)) !== null) {
                            const username = usernameMatch[1];
                            if (usernameDatabase[username]) {
                                const startColumn = usernameMatch.index + 1;
                                const baseRange = {
                                    startLineNumber: lineIndex + 1,
                                    startColumn: startColumn,
                                    endLineNumber: lineIndex + 1,
                                    endColumn: startColumn + usernameMatch[0].length
                                };

                                lenses.push({
                                    range: baseRange,
                                    id: `username-google-${lineIndex}-${usernameMatch.index}`,
                                    command: { id: 'username.google', title: 'ğŸ” Google', arguments: [username] }
                                });

                                lenses.push({
                                    range: baseRange,
                                    id: `username-twitter-${lineIndex}-${usernameMatch.index}`,
                                    command: { id: 'username.twitter', title: 'ğŸ¦ Twitter', arguments: [username] }
                                });
                            }
                        }

                        // URL lenses
                        const urlRegex = /https?:\/\/[^\s\)]+/g;
                        let urlMatch;
                        while ((urlMatch = urlRegex.exec(line)) !== null) {
                            const url = urlMatch[0];
                            if (urlDatabase[url]) {
                                const startColumn = urlMatch.index + 1;
                                lenses.push({
                                    range: {
                                        startLineNumber: lineIndex + 1,
                                        startColumn: startColumn,
                                        endLineNumber: lineIndex + 1,
                                        endColumn: startColumn + urlMatch[0].length
                                    },
                                    id: `url-open-${lineIndex}-${urlMatch.index}`,
                                    command: { id: 'url.open', title: 'ğŸ”— Open', arguments: [url] }
                                });
                            }
                        }
                    });

                    return { lenses, dispose: () => { } };
                }
            });

            // ===== COMMANDS =====
            ['username.google', 'username.twitter', 'url.open'].forEach(commandId => {
                monaco.editor.addCommand({
                    id: commandId,
                    run: function (accessor, arg) {
                        let url;
                        if (commandId === 'username.google') {
                            url = `https://www.google.com/search?q=${encodeURIComponent('@' + arg)}`;
                        } else if (commandId === 'username.twitter') {
                            url = `https://twitter.com/${arg}`;
                        } else if (commandId === 'url.open') {
                            url = arg;
                        }
                        if (url) window.open(url, '_blank');
                    }
                });
            });

            // ===== DECORATIONS AND MARKERS =====
            function updateAllDecorations() {
                const model = editor.getModel();
                const content = model.getValue();
                const lines = content.split('\n');
                const decorations = [];
                const markers = [];

                let inCodeBlock = false;

                lines.forEach((line, lineIndex) => {
                    const lineNumber = lineIndex + 1;

                    // Toggle code block state
                    if (line.trim().startsWith('```')) {
                        inCodeBlock = !inCodeBlock;
                        return;
                    }

                    if (!inCodeBlock) {
                        // Spell checking
                        const wordRegex = /\b[a-zA-Z']+\b/g;
                        let wordMatch;
                        while ((wordMatch = wordRegex.exec(line)) !== null) {
                            const word = wordMatch[0];
                            const beforeWord = line.substring(0, wordMatch.index);
                            const backticksBefore = (beforeWord.match(/`/g) || []).length;
                            if (backticksBefore % 2 === 1) continue;

                            if (spellCorrections[word.toLowerCase()]) {
                                markers.push({
                                    startLineNumber: lineNumber,
                                    startColumn: wordMatch.index + 1,
                                    endLineNumber: lineNumber,
                                    endColumn: wordMatch.index + 1 + word.length,
                                    message: `Misspelled: ${word}`,
                                    severity: monaco.MarkerSeverity.Warning,
                                    code: 'spelling'
                                });
                            }
                        }

                        // Username highlighting
                        const usernameRegex = /@(\w+)/g;
                        let usernameMatch;
                        while ((usernameMatch = usernameRegex.exec(line)) !== null) {
                            const username = usernameMatch[1];
                            if (usernameDatabase[username]) {
                                decorations.push({
                                    range: new monaco.Range(
                                        lineNumber, usernameMatch.index + 1,
                                        lineNumber, usernameMatch.index + usernameMatch[0].length + 1
                                    ),
                                    options: { inlineClassName: 'username-highlight' }
                                });
                            }
                        }

                        // Vocabulary highlighting
                        const vocabRegex = new RegExp(`\\b(${Object.keys(vocabulary).join('|')})\\b`, 'gi');
                        let vocabMatch;
                        while ((vocabMatch = vocabRegex.exec(line)) !== null) {
                            const beforeVocab = line.substring(0, vocabMatch.index);
                            const backticksBefore = (beforeVocab.match(/`/g) || []).length;
                            if (backticksBefore % 2 === 1) continue;

                            decorations.push({
                                range: new monaco.Range(
                                    lineNumber, vocabMatch.index + 1,
                                    lineNumber, vocabMatch.index + vocabMatch[0].length + 1
                                ),
                                options: { inlineClassName: 'vocab-word' }
                            });
                        }

                        // URL labels
                        const urlRegex = /https?:\/\/[^\s\)]+/g;
                        let urlMatch;
                        while ((urlMatch = urlRegex.exec(line)) !== null) {
                            const url = urlMatch[0];
                            const urlInfo = urlDatabase[url];
                            if (urlInfo) {
                                decorations.push({
                                    range: new monaco.Range(
                                        lineNumber, urlMatch.index + urlMatch[0].length + 1,
                                        lineNumber, urlMatch.index + urlMatch[0].length + 1
                                    ),
                                    options: {
                                        after: {
                                            content: ` ${urlInfo.tokens}`,
                                            inlineClassName: 'url-label'
                                        }
                                    }
                                });
                            }
                        }
                    }
                });

                // Apply decorations and markers
                editor.deltaDecorations([], decorations);
                monaco.editor.setModelMarkers(model, 'unified-features', markers);
            }

            // Update decorations on content change (debounced)
            let updateTimeout;
            editor.onDidChangeModelContent(() => {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(updateAllDecorations, 300);
            });

            // Initial update
            setTimeout(updateAllDecorations, 100);

            console.log('ğŸš€ Ultimate Monaco Editor loaded with all features!');
            console.log('ğŸ“Š Loaded databases:', {
                spellCorrections: Object.keys(spellCorrections).length,
                urls: Object.keys(urlDatabase).length,
                usernames: Object.keys(usernameDatabase).length,
                vocabulary: Object.keys(vocabulary).length
            });
        });
    </script>
</body>

</html>